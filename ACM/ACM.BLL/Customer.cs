using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ACM.BLL
{
    //Entity class
    public class Customer//Private by default added public to make it public
    {
        //Default conatructor=>REQUIRED WHEN MULTIPLE CONSTRUCTORS DEFINED and aditionally, usually required for initializate instances with autogenerated properties (No initializes Lists automatically)
        //In order to initialize list we have to reference the parametized constructor to initialize the list without repeat code
        //Reference the poarametized constructor by using -- :this(parmeters needed)--
        public Customer():this(0)
        {
           //List properties initialization since list properties default valu is null.
           // AddressList = new List<Address>(); WE ARE REPEATING CODE
        }

        //multiple constructors definitions (Default cosntructor overloading.) REQUIRES DEFAULT CONSTRUCTOR DEFINITION
        public Customer(int customerId) {
            CostumerId = customerId;
            //List properties initialization since list properties default valu is null.
            AddressList = new List<Address>();
        }

        //Creating dabase generated Unique Identifiers =>Usually this auto-generated properties REQUIRES DEFAULT CONSTRUCTOR DEFINITION in order to initialize instances
        public int CostumerId { get; private set; }
        //Using snippets
        public string EmailAddress { get; set; }

        //A customer have two adressess: 1. Home address and worck address. We can implement two diferent fields for each address like this
        //public Address HomeAddress { get; set; }
        //public Address WorkAddres { get; set; }
        //But since they are references to different instances of the same type, is more convenient to crate a list of this Addres type
        //Customer HAS A Address list of type Addres, Composing objects from objects of different clases is called COMPOSITION relationships --HAS A --.
        public List<Address> AddressList { get; set; }
        //AddressList is a REFERENCED OBJECT property. Has to be populated
        //Remember that list are not automatically initiated like the pther props so you have to modify the constructor to add this initialization tho avoid null value exemptions.

        //Backing field for Last name: Needed because the public property can be setted so we need to hold data somewhere.
        private string _lastName;//encapsulate (hide data) by maiking it private. Requires public accesors to make it public available.

        //C# Property
        public string LastName// If only avaiable for code inside project, use internal string LastName{}.
        {
            //Public accesors for _lastName field
            get//if not => write only property.
            {
                //Add any code to perform on the value before returned... such as validating accessing user, formating output, converting output...
                return _lastName;
            }
            set//if not => read only property.
            {
                //Add any code to perform on the value before stored such as validating input, formating and conveting input
                _lastName = value;
            }
        }

        //Shorthand definition
        //Optionally, if not additional code on accessors you can use AUTOIMPLEMENTED PROPERTIES which implicity define the backing field
        public string FirstName { get; set; }

        //Creating compund property
        public string FullName//no setter because no other code modify this property.
        {
            get
            {
                string fullName = LastName;
                if (!string.IsNullOrWhiteSpace(FirstName))
                {
                    if (!string.IsNullOrWhiteSpace(fullName))
                        {
                            fullName += ", ";
                        }

                    fullName += FirstName;
                }
                return fullName;
            }
        }

        //Creating a static: Bellongs to the class rather than a specific instance. Callable with the ClassName.staticPropertyName
        public static int InstanceCounter { get; set; }

        //Methods

        ///<summary>
        ///Validates costumer data
        ///</summary>
        ///<returns></returns>
        public bool Validate()
        {
            var isValid = true;

            if (string.IsNullOrWhiteSpace(FirstName) && string.IsNullOrEmpty(LastName)) isValid = false;
            if (string.IsNullOrWhiteSpace(EmailAddress)) isValid = false;
            return isValid;
        }

        //MOVED TO THE REPOSITORY WHO IS THE RESPONSIBLE TO ACCESS DATA
                ///<summary>
                ///Retrieve informations for a specific customer
                ///</summary>
                ///<returns></returns>
                //public Customer Retrieve(int costumerId)
                //{

                //    return new Customer();
                //}

                ///<summary>
                ///Overload the Retrieve method for retreive informations for multiple customers
                ///</summary>
                ///<returns></returns>
                //public List<Customer> Retrieve()//Same name diferent signature. Method overload because it perform similar functionalities and returns same type results than non overload method.
                //{

                //    return new List<Customer>();
                //}

                ///<summary>
                ///Save or add a new customer to the DB
                ///</summary>
                ///<returns></returns>
                //public bool Save()
                //{

                //    return true;
                //}
    }

    
}

